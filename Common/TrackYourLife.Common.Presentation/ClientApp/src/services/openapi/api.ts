/* tslint:disable */
/* eslint-disable */
/**
 * EventReminder API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddFoodDiaryEntryRequest
 */
export interface AddFoodDiaryEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof AddFoodDiaryEntryRequest
     */
    'foodId': string;
    /**
     * 
     * @type {MealTypes}
     * @memberof AddFoodDiaryEntryRequest
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {string}
     * @memberof AddFoodDiaryEntryRequest
     */
    'servingSizeId': string;
    /**
     * 
     * @type {number}
     * @memberof AddFoodDiaryEntryRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof AddFoodDiaryEntryRequest
     */
    'entryDate': string;
}


/**
 * 
 * @export
 * @interface AddUserGoalRequest
 */
export interface AddUserGoalRequest {
    /**
     * 
     * @type {number}
     * @memberof AddUserGoalRequest
     */
    'value': number;
    /**
     * 
     * @type {UserGoalType}
     * @memberof AddUserGoalRequest
     */
    'type': UserGoalType;
    /**
     * 
     * @type {UserGoalPerPeriod}
     * @memberof AddUserGoalRequest
     */
    'perPeriod': UserGoalPerPeriod;
    /**
     * 
     * @type {string}
     * @memberof AddUserGoalRequest
     */
    'startDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof AddUserGoalRequest
     */
    'force'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AddUserGoalRequest
     */
    'endDate'?: string | null;
}


/**
 * 
 * @export
 * @interface Energy
 */
export interface Energy {
    /**
     * 
     * @type {string}
     * @memberof Energy
     */
    'unit': string;
    /**
     * 
     * @type {number}
     * @memberof Energy
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface FoodDiaryEntryListResponse
 */
export interface FoodDiaryEntryListResponse {
    /**
     * 
     * @type {Array<FoodDiaryEntryResponse>}
     * @memberof FoodDiaryEntryListResponse
     */
    'breakfast': Array<FoodDiaryEntryResponse>;
    /**
     * 
     * @type {Array<FoodDiaryEntryResponse>}
     * @memberof FoodDiaryEntryListResponse
     */
    'lunch': Array<FoodDiaryEntryResponse>;
    /**
     * 
     * @type {Array<FoodDiaryEntryResponse>}
     * @memberof FoodDiaryEntryListResponse
     */
    'dinner': Array<FoodDiaryEntryResponse>;
    /**
     * 
     * @type {Array<FoodDiaryEntryResponse>}
     * @memberof FoodDiaryEntryListResponse
     */
    'snacks': Array<FoodDiaryEntryResponse>;
}
/**
 * 
 * @export
 * @interface FoodDiaryEntryResponse
 */
export interface FoodDiaryEntryResponse {
    /**
     * 
     * @type {string}
     * @memberof FoodDiaryEntryResponse
     */
    'id': string;
    /**
     * 
     * @type {FoodResponse}
     * @memberof FoodDiaryEntryResponse
     */
    'food': FoodResponse;
    /**
     * 
     * @type {MealTypes}
     * @memberof FoodDiaryEntryResponse
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {number}
     * @memberof FoodDiaryEntryResponse
     */
    'quantity': number;
    /**
     * 
     * @type {ServingSize}
     * @memberof FoodDiaryEntryResponse
     */
    'servingSize': ServingSize;
    /**
     * 
     * @type {string}
     * @memberof FoodDiaryEntryResponse
     */
    'entryDate': string;
}


/**
 * 
 * @export
 * @interface FoodListResponse
 */
export interface FoodListResponse {
    /**
     * 
     * @type {FoodResponsePagedList}
     * @memberof FoodListResponse
     */
    'list': FoodResponsePagedList;
}
/**
 * 
 * @export
 * @interface FoodResponse
 */
export interface FoodResponse {
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'brandName': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'name': string;
    /**
     * 
     * @type {NutritionalContent}
     * @memberof FoodResponse
     */
    'nutritionalContents': NutritionalContent;
    /**
     * 
     * @type {Array<ServingSizeResponse>}
     * @memberof FoodResponse
     */
    'servingSizes': Array<ServingSizeResponse>;
}
/**
 * 
 * @export
 * @interface FoodResponsePagedList
 */
export interface FoodResponsePagedList {
    /**
     * 
     * @type {Array<FoodResponse>}
     * @memberof FoodResponsePagedList
     */
    'items': Array<FoodResponse>;
    /**
     * 
     * @type {number}
     * @memberof FoodResponsePagedList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof FoodResponsePagedList
     */
    'pageSize': number;
    /**
     * 
     * @type {boolean}
     * @memberof FoodResponsePagedList
     */
    'hasPreviousPage': boolean;
    /**
     * 
     * @type {number}
     * @memberof FoodResponsePagedList
     */
    'maxPage': number;
    /**
     * 
     * @type {boolean}
     * @memberof FoodResponsePagedList
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface IStronglyTypedGuid
 */
export interface IStronglyTypedGuid {
    /**
     * 
     * @type {string}
     * @memberof IStronglyTypedGuid
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface IdResponse
 */
export interface IdResponse {
    /**
     * 
     * @type {string}
     * @memberof IdResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface LogInUserRequest
 */
export interface LogInUserRequest {
    /**
     * 
     * @type {string}
     * @memberof LogInUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LogInUserRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MealTypes = {
    Breakfast: 'Breakfast',
    Lunch: 'Lunch',
    Dinner: 'Dinner',
    Snacks: 'Snacks'
} as const;

export type MealTypes = typeof MealTypes[keyof typeof MealTypes];


/**
 * 
 * @export
 * @interface NutritionalContent
 */
export interface NutritionalContent {
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'calcium': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'carbohydrates': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'cholesterol': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'fat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'fiber': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'iron': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'monounsaturatedFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'netCarbs': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'polyunsaturatedFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'potassium': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'protein': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'saturatedFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'sodium': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'sugar': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'transFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'vitaminA': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'vitaminC': number;
    /**
     * 
     * @type {Energy}
     * @memberof NutritionalContent
     */
    'energy': Energy;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}
/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface ServingSize
 */
export interface ServingSize {
    /**
     * 
     * @type {string}
     * @memberof ServingSize
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ServingSize
     */
    'nutritionMultiplier': number;
    /**
     * 
     * @type {string}
     * @memberof ServingSize
     */
    'unit': string;
    /**
     * 
     * @type {number}
     * @memberof ServingSize
     */
    'value': number;
    /**
     * 
     * @type {number}
     * @memberof ServingSize
     */
    'apiId'?: number | null;
}
/**
 * 
 * @export
 * @interface ServingSizeResponse
 */
export interface ServingSizeResponse {
    /**
     * 
     * @type {string}
     * @memberof ServingSizeResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ServingSizeResponse
     */
    'nutritionMultiplier': number;
    /**
     * 
     * @type {number}
     * @memberof ServingSizeResponse
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ServingSizeResponse
     */
    'unit': string;
    /**
     * 
     * @type {number}
     * @memberof ServingSizeResponse
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'tokenValue': string;
}
/**
 * 
 * @export
 * @interface TotalCaloriesResponse
 */
export interface TotalCaloriesResponse {
    /**
     * 
     * @type {number}
     * @memberof TotalCaloriesResponse
     */
    'totalCalories': number;
}
/**
 * 
 * @export
 * @interface UpdateFoodDiaryEntryRequest
 */
export interface UpdateFoodDiaryEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFoodDiaryEntryRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateFoodDiaryEntryRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateFoodDiaryEntryRequest
     */
    'servingSizeId': string;
    /**
     * 
     * @type {MealTypes}
     * @memberof UpdateFoodDiaryEntryRequest
     */
    'mealType': MealTypes;
}


/**
 * 
 * @export
 * @interface UpdateUserGoalRequest
 */
export interface UpdateUserGoalRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserGoalRequest
     */
    'id': string;
    /**
     * 
     * @type {UserGoalType}
     * @memberof UpdateUserGoalRequest
     */
    'type': UserGoalType;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserGoalRequest
     */
    'value': number;
    /**
     * 
     * @type {UserGoalPerPeriod}
     * @memberof UpdateUserGoalRequest
     */
    'perPeriod': UserGoalPerPeriod;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserGoalRequest
     */
    'startDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserGoalRequest
     */
    'force'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserGoalRequest
     */
    'endDate'?: string | null;
}


/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserGoalPerPeriod = {
    Day: 'Day',
    Week: 'Week',
    Month: 'Month'
} as const;

export type UserGoalPerPeriod = typeof UserGoalPerPeriod[keyof typeof UserGoalPerPeriod];


/**
 * 
 * @export
 * @interface UserGoalResponse
 */
export interface UserGoalResponse {
    /**
     * 
     * @type {string}
     * @memberof UserGoalResponse
     */
    'id': string;
    /**
     * 
     * @type {UserGoalType}
     * @memberof UserGoalResponse
     */
    'type': UserGoalType;
    /**
     * 
     * @type {number}
     * @memberof UserGoalResponse
     */
    'value': number;
    /**
     * 
     * @type {UserGoalPerPeriod}
     * @memberof UserGoalResponse
     */
    'perPeriod': UserGoalPerPeriod;
    /**
     * 
     * @type {string}
     * @memberof UserGoalResponse
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof UserGoalResponse
     */
    'endDate'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserGoalType = {
    Calories: 'Calories',
    Water: 'Water'
} as const;

export type UserGoalType = typeof UserGoalType[keyof typeof UserGoalType];


/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'lastName': string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LogInUserRequest} logInUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logIn: async (logInUserRequest: LogInUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logInUserRequest' is not null or undefined
            assertParamExists('logIn', 'logInUserRequest', logInUserRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logInUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerUserRequest: RegisterUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequest' is not null or undefined
            assertParamExists('register', 'registerUserRequest', registerUserRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LogInUserRequest} logInUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logIn(logInUserRequest: LogInUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logIn(logInUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logOut(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logOut(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {LogInUserRequest} logInUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logIn(logInUserRequest: LogInUserRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.logIn(logInUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOut(options?: any): AxiosPromise<void> {
            return localVarFp.logOut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerUserRequest: RegisterUserRequest, options?: any): AxiosPromise<IdResponse> {
            return localVarFp.register(registerUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {LogInUserRequest} logInUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logIn(logInUserRequest: LogInUserRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logIn(logInUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logOut(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logOut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterUserRequest} registerUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodApi - axios parameter creator
 * @export
 */
export const FoodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/api/food/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchParam 
         * @param {number} page 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (searchParam: string, page: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchParam' is not null or undefined
            assertParamExists('getList', 'searchParam', searchParam)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getList', 'page', page)
            const localVarPath = `/api/food/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (searchParam !== undefined) {
                localVarQueryParameter['SearchParam'] = searchParam;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodApi - functional programming interface
 * @export
 */
export const FoodApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchParam 
         * @param {number} page 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(searchParam: string, page: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(searchParam, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.getList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodApi - factory interface
 * @export
 */
export const FoodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: any): AxiosPromise<FoodResponse> {
            return localVarFp.getById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchParam 
         * @param {number} page 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(searchParam: string, page: number, pageSize?: number, options?: any): AxiosPromise<FoodListResponse> {
            return localVarFp.getList(searchParam, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodApi - object-oriented interface
 * @export
 * @class FoodApi
 * @extends {BaseAPI}
 */
export class FoodApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public getById(id: string, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).getById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchParam 
     * @param {number} page 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public getList(searchParam: string, page: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).getList(searchParam, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodDiaryApi - axios parameter creator
 * @export
 */
export const FoodDiaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddFoodDiaryEntryRequest} addFoodDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntry: async (addFoodDiaryEntryRequest: AddFoodDiaryEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addFoodDiaryEntryRequest' is not null or undefined
            assertParamExists('addEntry', 'addFoodDiaryEntryRequest', addFoodDiaryEntryRequest)
            const localVarPath = `/api/foodDiary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFoodDiaryEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntry: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEntry', 'id', id)
            const localVarPath = `/api/foodDiary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} day 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByDate: async (day: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('getByDate', 'day', day)
            const localVarPath = `/api/foodDiary/by-date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (day !== undefined) {
                localVarQueryParameter['Day'] = (day as any instanceof Date) ?
                    (day as any).toISOString().substring(0,10) :
                    day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalCalories: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getTotalCalories', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getTotalCalories', 'endDate', endDate)
            const localVarPath = `/api/foodDiary/total-calories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateFoodDiaryEntryRequest} updateFoodDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntry: async (updateFoodDiaryEntryRequest: UpdateFoodDiaryEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFoodDiaryEntryRequest' is not null or undefined
            assertParamExists('updateEntry', 'updateFoodDiaryEntryRequest', updateFoodDiaryEntryRequest)
            const localVarPath = `/api/foodDiary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFoodDiaryEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodDiaryApi - functional programming interface
 * @export
 */
export const FoodDiaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodDiaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddFoodDiaryEntryRequest} addFoodDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntry(addFoodDiaryEntryRequest: AddFoodDiaryEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntry(addFoodDiaryEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiaryApi.addEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntry(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntry(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiaryApi.deleteEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} day 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByDate(day: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodDiaryEntryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByDate(day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiaryApi.getByDate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalCalories(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotalCaloriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalCalories(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiaryApi.getTotalCalories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateFoodDiaryEntryRequest} updateFoodDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntry(updateFoodDiaryEntryRequest: UpdateFoodDiaryEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntry(updateFoodDiaryEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiaryApi.updateEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodDiaryApi - factory interface
 * @export
 */
export const FoodDiaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodDiaryApiFp(configuration)
    return {
        /**
         * 
         * @param {AddFoodDiaryEntryRequest} addFoodDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntry(addFoodDiaryEntryRequest: AddFoodDiaryEntryRequest, options?: any): AxiosPromise<IdResponse> {
            return localVarFp.addEntry(addFoodDiaryEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntry(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} day 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByDate(day: string, options?: any): AxiosPromise<FoodDiaryEntryListResponse> {
            return localVarFp.getByDate(day, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalCalories(startDate: string, endDate: string, options?: any): AxiosPromise<TotalCaloriesResponse> {
            return localVarFp.getTotalCalories(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateFoodDiaryEntryRequest} updateFoodDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntry(updateFoodDiaryEntryRequest: UpdateFoodDiaryEntryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntry(updateFoodDiaryEntryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodDiaryApi - object-oriented interface
 * @export
 * @class FoodDiaryApi
 * @extends {BaseAPI}
 */
export class FoodDiaryApi extends BaseAPI {
    /**
     * 
     * @param {AddFoodDiaryEntryRequest} addFoodDiaryEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiaryApi
     */
    public addEntry(addFoodDiaryEntryRequest: AddFoodDiaryEntryRequest, options?: RawAxiosRequestConfig) {
        return FoodDiaryApiFp(this.configuration).addEntry(addFoodDiaryEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiaryApi
     */
    public deleteEntry(id: string, options?: RawAxiosRequestConfig) {
        return FoodDiaryApiFp(this.configuration).deleteEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} day 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiaryApi
     */
    public getByDate(day: string, options?: RawAxiosRequestConfig) {
        return FoodDiaryApiFp(this.configuration).getByDate(day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} startDate 
     * @param {string} endDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiaryApi
     */
    public getTotalCalories(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return FoodDiaryApiFp(this.configuration).getTotalCalories(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateFoodDiaryEntryRequest} updateFoodDiaryEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiaryApi
     */
    public updateEntry(updateFoodDiaryEntryRequest: UpdateFoodDiaryEntryRequest, options?: RawAxiosRequestConfig) {
        return FoodDiaryApiFp(this.configuration).updateEntry(updateFoodDiaryEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('resendVerificationEmail', 'email', email)
            const localVarPath = `/api/user/resend-verification-email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('update', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProfileImage: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadProfileImage', 'file', file)
            const localVarPath = `/api/user/upload-profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmail', 'token', token)
            const localVarPath = `/api/user/verify-email/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getCurrentUserData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVerificationEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerificationEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProfileImage(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProfileImage(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.uploadProfileImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options?: any): AxiosPromise<void> {
            return localVarFp._delete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserData(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getCurrentUserData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationEmail(email: string, options?: any): AxiosPromise<void> {
            return localVarFp.resendVerificationEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.update(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProfileImage(file: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadProfileImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.verifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public _delete(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration)._delete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUserData(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUserData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resendVerificationEmail(email: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resendVerificationEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public update(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).update(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public uploadProfileImage(file: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).uploadProfileImage(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).verifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserGoalApi - axios parameter creator
 * @export
 */
export const UserGoalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddUserGoalRequest} addUserGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal: async (addUserGoalRequest: AddUserGoalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addUserGoalRequest' is not null or undefined
            assertParamExists('addGoal', 'addUserGoalRequest', addUserGoalRequest)
            const localVarPath = `/api/userGoal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserGoalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserGoalType} goalType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveGoal: async (goalType: UserGoalType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalType' is not null or undefined
            assertParamExists('getActiveGoal', 'goalType', goalType)
            const localVarPath = `/api/userGoal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (goalType !== undefined) {
                localVarQueryParameter['GoalType'] = goalType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserGoalRequest} updateUserGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal: async (updateUserGoalRequest: UpdateUserGoalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserGoalRequest' is not null or undefined
            assertParamExists('updateGoal', 'updateUserGoalRequest', updateUserGoalRequest)
            const localVarPath = `/api/userGoal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserGoalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserGoalApi - functional programming interface
 * @export
 */
export const UserGoalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserGoalApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddUserGoalRequest} addUserGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGoal(addUserGoalRequest: AddUserGoalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGoalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGoal(addUserGoalRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGoalApi.addGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserGoalType} goalType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveGoal(goalType: UserGoalType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGoalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveGoal(goalType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGoalApi.getActiveGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserGoalRequest} updateUserGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoal(updateUserGoalRequest: UpdateUserGoalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoal(updateUserGoalRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGoalApi.updateGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserGoalApi - factory interface
 * @export
 */
export const UserGoalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserGoalApiFp(configuration)
    return {
        /**
         * 
         * @param {AddUserGoalRequest} addUserGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal(addUserGoalRequest: AddUserGoalRequest, options?: any): AxiosPromise<UserGoalResponse> {
            return localVarFp.addGoal(addUserGoalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserGoalType} goalType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveGoal(goalType: UserGoalType, options?: any): AxiosPromise<UserGoalResponse> {
            return localVarFp.getActiveGoal(goalType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserGoalRequest} updateUserGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(updateUserGoalRequest: UpdateUserGoalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGoal(updateUserGoalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserGoalApi - object-oriented interface
 * @export
 * @class UserGoalApi
 * @extends {BaseAPI}
 */
export class UserGoalApi extends BaseAPI {
    /**
     * 
     * @param {AddUserGoalRequest} addUserGoalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGoalApi
     */
    public addGoal(addUserGoalRequest: AddUserGoalRequest, options?: RawAxiosRequestConfig) {
        return UserGoalApiFp(this.configuration).addGoal(addUserGoalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserGoalType} goalType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGoalApi
     */
    public getActiveGoal(goalType: UserGoalType, options?: RawAxiosRequestConfig) {
        return UserGoalApiFp(this.configuration).getActiveGoal(goalType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserGoalRequest} updateUserGoalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGoalApi
     */
    public updateGoal(updateUserGoalRequest: UpdateUserGoalRequest, options?: RawAxiosRequestConfig) {
        return UserGoalApiFp(this.configuration).updateGoal(updateUserGoalRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



