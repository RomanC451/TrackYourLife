/* tslint:disable */
/* eslint-disable */
/**
 * TrackYourLifeDotnet.App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddFoodDiaryRequest
 */
export interface AddFoodDiaryRequest {
    /**
     * 
     * @type {string}
     * @memberof AddFoodDiaryRequest
     */
    'foodId': string;
    /**
     * 
     * @type {MealTypes}
     * @memberof AddFoodDiaryRequest
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {string}
     * @memberof AddFoodDiaryRequest
     */
    'servingSizeId': string;
    /**
     * 
     * @type {number}
     * @memberof AddFoodDiaryRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof AddFoodDiaryRequest
     */
    'entryDate': string;
}


/**
 * 
 * @export
 * @interface AddGoalRequest
 */
export interface AddGoalRequest {
    /**
     * 
     * @type {number}
     * @memberof AddGoalRequest
     */
    'value': number;
    /**
     * 
     * @type {GoalType}
     * @memberof AddGoalRequest
     */
    'type': GoalType;
    /**
     * 
     * @type {GoalPeriod}
     * @memberof AddGoalRequest
     */
    'perPeriod': GoalPeriod;
    /**
     * 
     * @type {string}
     * @memberof AddGoalRequest
     */
    'startDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof AddGoalRequest
     */
    'force'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AddGoalRequest
     */
    'endDate'?: string | null;
}


/**
 * 
 * @export
 * @interface AddIngredientRequest
 */
export interface AddIngredientRequest {
    /**
     * 
     * @type {string}
     * @memberof AddIngredientRequest
     */
    'foodId': string;
    /**
     * 
     * @type {string}
     * @memberof AddIngredientRequest
     */
    'servingSizeId': string;
    /**
     * 
     * @type {number}
     * @memberof AddIngredientRequest
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface AddRecipeDiaryRequest
 */
export interface AddRecipeDiaryRequest {
    /**
     * 
     * @type {string}
     * @memberof AddRecipeDiaryRequest
     */
    'recipeId': string;
    /**
     * 
     * @type {MealTypes}
     * @memberof AddRecipeDiaryRequest
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {number}
     * @memberof AddRecipeDiaryRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof AddRecipeDiaryRequest
     */
    'entryDate': string;
}


/**
 * 
 * @export
 * @interface CreateRecipeRequest
 */
export interface CreateRecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DiaryType = {
    FoodDiary: 'FoodDiary',
    RecipeDiary: 'RecipeDiary'
} as const;

export type DiaryType = typeof DiaryType[keyof typeof DiaryType];


/**
 * 
 * @export
 * @interface Energy
 */
export interface Energy {
    /**
     * 
     * @type {string}
     * @memberof Energy
     */
    'unit': string;
    /**
     * 
     * @type {number}
     * @memberof Energy
     */
    'value': number;
}
/**
 * the dto used to send an error response to the client
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * the http status code sent to the client. default is 400.
     * @type {number}
     * @memberof ErrorResponse
     */
    'statusCode': number;
    /**
     * the message for the error response
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * the collection of errors for the current context
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ErrorResponse
     */
    'errors': { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface FoodDiaryDto
 */
export interface FoodDiaryDto {
    /**
     * 
     * @type {string}
     * @memberof FoodDiaryDto
     */
    'id': string;
    /**
     * 
     * @type {FoodDto}
     * @memberof FoodDiaryDto
     */
    'food': FoodDto;
    /**
     * 
     * @type {MealTypes}
     * @memberof FoodDiaryDto
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {number}
     * @memberof FoodDiaryDto
     */
    'quantity': number;
    /**
     * 
     * @type {ServingSizeDto}
     * @memberof FoodDiaryDto
     */
    'servingSize': ServingSizeDto;
    /**
     * 
     * @type {string}
     * @memberof FoodDiaryDto
     */
    'date': string;
}


/**
 * 
 * @export
 * @interface FoodDto
 */
export interface FoodDto {
    /**
     * 
     * @type {string}
     * @memberof FoodDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FoodDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FoodDto
     */
    'brandName': string;
    /**
     * 
     * @type {string}
     * @memberof FoodDto
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof FoodDto
     */
    'name': string;
    /**
     * 
     * @type {NutritionalContent}
     * @memberof FoodDto
     */
    'nutritionalContents': NutritionalContent;
    /**
     * 
     * @type {{ [key: string]: ServingSizeDto; }}
     * @memberof FoodDto
     */
    'servingSizes': { [key: string]: ServingSizeDto; };
}
/**
 * 
 * @export
 * @interface GetNutritionDiariesByDateResponse
 */
export interface GetNutritionDiariesByDateResponse {
    /**
     * 
     * @type {{ [key: string]: Array<NutritionDiaryDto>; }}
     * @memberof GetNutritionDiariesByDateResponse
     */
    'diaries': { [key: string]: Array<NutritionDiaryDto>; };
}
/**
 * 
 * @export
 * @interface GoalDto
 */
export interface GoalDto {
    /**
     * 
     * @type {string}
     * @memberof GoalDto
     */
    'id': string;
    /**
     * 
     * @type {GoalType}
     * @memberof GoalDto
     */
    'type': GoalType;
    /**
     * 
     * @type {number}
     * @memberof GoalDto
     */
    'value': number;
    /**
     * 
     * @type {GoalPeriod}
     * @memberof GoalDto
     */
    'perPeriod': GoalPeriod;
    /**
     * 
     * @type {string}
     * @memberof GoalDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof GoalDto
     */
    'endDate': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoalPeriod = {
    Day: 'Day',
    Week: 'Week',
    Month: 'Month'
} as const;

export type GoalPeriod = typeof GoalPeriod[keyof typeof GoalPeriod];


/**
 * 
 * @export
 * @enum {string}
 */

export const GoalType = {
    Calories: 'Calories',
    Water: 'Water'
} as const;

export type GoalType = typeof GoalType[keyof typeof GoalType];


/**
 * 
 * @export
 * @interface IStronglyTypedGuid
 */
export interface IStronglyTypedGuid {
    /**
     * 
     * @type {string}
     * @memberof IStronglyTypedGuid
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface IdResponse
 */
export interface IdResponse {
    /**
     * 
     * @type {string}
     * @memberof IdResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface IngredientDto
 */
export interface IngredientDto {
    /**
     * 
     * @type {string}
     * @memberof IngredientDto
     */
    'id': string;
    /**
     * 
     * @type {FoodDto}
     * @memberof IngredientDto
     */
    'food': FoodDto;
    /**
     * 
     * @type {ServingSizeDto}
     * @memberof IngredientDto
     */
    'servingSize': ServingSizeDto;
    /**
     * 
     * @type {number}
     * @memberof IngredientDto
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface LogInUserRequest
 */
export interface LogInUserRequest {
    /**
     * 
     * @type {string}
     * @memberof LogInUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LogInUserRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MealTypes = {
    Breakfast: 'Breakfast',
    Lunch: 'Lunch',
    Dinner: 'Dinner',
    Snacks: 'Snacks'
} as const;

export type MealTypes = typeof MealTypes[keyof typeof MealTypes];


/**
 * 
 * @export
 * @interface NutritionDiaryDto
 */
export interface NutritionDiaryDto {
    /**
     * 
     * @type {string}
     * @memberof NutritionDiaryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NutritionDiaryDto
     */
    'name': string;
    /**
     * 
     * @type {NutritionDiaryDtoServingSize}
     * @memberof NutritionDiaryDto
     */
    'servingSize'?: NutritionDiaryDtoServingSize | null;
    /**
     * 
     * @type {NutritionalContent}
     * @memberof NutritionDiaryDto
     */
    'nutritionalContents': NutritionalContent;
    /**
     * 
     * @type {number}
     * @memberof NutritionDiaryDto
     */
    'nutritionMultiplier': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionDiaryDto
     */
    'quantity': number;
    /**
     * 
     * @type {MealTypes}
     * @memberof NutritionDiaryDto
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {DiaryType}
     * @memberof NutritionDiaryDto
     */
    'diaryType': DiaryType;
    /**
     * 
     * @type {string}
     * @memberof NutritionDiaryDto
     */
    'date': string;
}


/**
 * @type NutritionDiaryDtoServingSize
 * @export
 */
export type NutritionDiaryDtoServingSize = ServingSizeDto;

/**
 * 
 * @export
 * @interface NutritionalContent
 */
export interface NutritionalContent {
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'calcium': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'carbohydrates': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'cholesterol': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'fat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'fiber': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'iron': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'monounsaturatedFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'netCarbs': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'polyunsaturatedFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'potassium': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'protein': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'saturatedFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'sodium': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'sugar': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'transFat': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'vitaminA': number;
    /**
     * 
     * @type {number}
     * @memberof NutritionalContent
     */
    'vitaminC': number;
    /**
     * 
     * @type {Energy}
     * @memberof NutritionalContent
     */
    'energy': Energy;
}
/**
 * 
 * @export
 * @interface PagedListOfFoodDto
 */
export interface PagedListOfFoodDto {
    /**
     * 
     * @type {Array<FoodDto>}
     * @memberof PagedListOfFoodDto
     */
    'items': Array<FoodDto>;
    /**
     * 
     * @type {number}
     * @memberof PagedListOfFoodDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PagedListOfFoodDto
     */
    'pageSize': number;
    /**
     * 
     * @type {boolean}
     * @memberof PagedListOfFoodDto
     */
    'hasPreviousPage': boolean;
    /**
     * 
     * @type {number}
     * @memberof PagedListOfFoodDto
     */
    'maxPage': number;
    /**
     * 
     * @type {boolean}
     * @memberof PagedListOfFoodDto
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}
/**
 * 
 * @export
 * @interface RecipeDiaryDto
 */
export interface RecipeDiaryDto {
    /**
     * 
     * @type {string}
     * @memberof RecipeDiaryDto
     */
    'id': string;
    /**
     * 
     * @type {RecipeDto}
     * @memberof RecipeDiaryDto
     */
    'recipe': RecipeDto;
    /**
     * 
     * @type {MealTypes}
     * @memberof RecipeDiaryDto
     */
    'mealType': MealTypes;
    /**
     * 
     * @type {number}
     * @memberof RecipeDiaryDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof RecipeDiaryDto
     */
    'date': string;
}


/**
 * 
 * @export
 * @interface RecipeDto
 */
export interface RecipeDto {
    /**
     * 
     * @type {string}
     * @memberof RecipeDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RecipeDto
     */
    'name': string;
    /**
     * 
     * @type {Array<IngredientDto>}
     * @memberof RecipeDto
     */
    'ingredients': Array<IngredientDto>;
    /**
     * 
     * @type {NutritionalContent}
     * @memberof RecipeDto
     */
    'nutritionalContents': NutritionalContent;
}
/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface ServingSizeDto
 */
export interface ServingSizeDto {
    /**
     * 
     * @type {string}
     * @memberof ServingSizeDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ServingSizeDto
     */
    'nutritionMultiplier': number;
    /**
     * 
     * @type {number}
     * @memberof ServingSizeDto
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ServingSizeDto
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'tokenValue': string;
}
/**
 * 
 * @export
 * @interface UpdateCurrentUserRequest
 */
export interface UpdateCurrentUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface UpdateFoodDiaryRequest
 */
export interface UpdateFoodDiaryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFoodDiaryRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateFoodDiaryRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateFoodDiaryRequest
     */
    'servingSizeId': string;
    /**
     * 
     * @type {MealTypes}
     * @memberof UpdateFoodDiaryRequest
     */
    'mealType': MealTypes;
}


/**
 * 
 * @export
 * @interface UpdateGoalRequest
 */
export interface UpdateGoalRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'id': string;
    /**
     * 
     * @type {GoalType}
     * @memberof UpdateGoalRequest
     */
    'type': GoalType;
    /**
     * 
     * @type {number}
     * @memberof UpdateGoalRequest
     */
    'value': number;
    /**
     * 
     * @type {GoalPeriod}
     * @memberof UpdateGoalRequest
     */
    'perPeriod': GoalPeriod;
    /**
     * 
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'startDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGoalRequest
     */
    'force'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'endDate'?: string | null;
}


/**
 * 
 * @export
 * @interface UpdateIngredientRequest
 */
export interface UpdateIngredientRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    'servingSizeId': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateIngredientRequest
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface UpdateRecipeDiaryRequest
 */
export interface UpdateRecipeDiaryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateRecipeDiaryRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateRecipeDiaryRequest
     */
    'quantity': number;
    /**
     * 
     * @type {MealTypes}
     * @memberof UpdateRecipeDiaryRequest
     */
    'mealType': MealTypes;
}


/**
 * 
 * @export
 * @interface UpdateRecipeNameRequest
 */
export interface UpdateRecipeNameRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateRecipeNameRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LogInUserRequest} logInUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (logInUserRequest: LogInUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logInUserRequest' is not null or undefined
            assertParamExists('loginUser', 'logInUserRequest', logInUserRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logInUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest: RegisterUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequest' is not null or undefined
            assertParamExists('registerUser', 'registerUserRequest', registerUserRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailVerification: async (email: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('resendEmailVerification', 'email', email)
            const localVarPath = `/api/auth/resend-verification-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logOutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logOutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logOutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LogInUserRequest} logInUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(logInUserRequest: LogInUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(logInUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmailVerification(email: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmailVerification(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resendEmailVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logOutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LogInUserRequest} logInUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(logInUserRequest: LogInUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.loginUser(logInUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailVerification(email: string | null, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendEmailVerification(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifyEmail(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logOutUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logOutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LogInUserRequest} logInUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginUser(logInUserRequest: LogInUserRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginUser(logInUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterUserRequest} registerUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerUser(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resendEmailVerification(email: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resendEmailVerification(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyEmail(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyEmail(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodDiariesApi - axios parameter creator
 * @export
 */
export const FoodDiariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddFoodDiaryRequest} addFoodDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFoodDiary: async (addFoodDiaryRequest: AddFoodDiaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addFoodDiaryRequest' is not null or undefined
            assertParamExists('addFoodDiary', 'addFoodDiaryRequest', addFoodDiaryRequest)
            const localVarPath = `/api/food-diaries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFoodDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFoodDiary: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFoodDiary', 'id', id)
            const localVarPath = `/api/food-diaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFoodDiaryById: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFoodDiaryById', 'id', id)
            const localVarPath = `/api/food-diaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateFoodDiaryRequest} updateFoodDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFoodDiary: async (updateFoodDiaryRequest: UpdateFoodDiaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFoodDiaryRequest' is not null or undefined
            assertParamExists('updateFoodDiary', 'updateFoodDiaryRequest', updateFoodDiaryRequest)
            const localVarPath = `/api/food-diaries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFoodDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodDiariesApi - functional programming interface
 * @export
 */
export const FoodDiariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodDiariesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddFoodDiaryRequest} addFoodDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFoodDiary(addFoodDiaryRequest: AddFoodDiaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFoodDiary(addFoodDiaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiariesApi.addFoodDiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFoodDiary(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFoodDiary(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiariesApi.deleteFoodDiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFoodDiaryById(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodDiaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFoodDiaryById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiariesApi.getFoodDiaryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateFoodDiaryRequest} updateFoodDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFoodDiary(updateFoodDiaryRequest: UpdateFoodDiaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFoodDiary(updateFoodDiaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodDiariesApi.updateFoodDiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodDiariesApi - factory interface
 * @export
 */
export const FoodDiariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodDiariesApiFp(configuration)
    return {
        /**
         * 
         * @param {AddFoodDiaryRequest} addFoodDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFoodDiary(addFoodDiaryRequest: AddFoodDiaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdResponse> {
            return localVarFp.addFoodDiary(addFoodDiaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFoodDiary(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFoodDiary(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFoodDiaryById(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<FoodDiaryDto> {
            return localVarFp.getFoodDiaryById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateFoodDiaryRequest} updateFoodDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFoodDiary(updateFoodDiaryRequest: UpdateFoodDiaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFoodDiary(updateFoodDiaryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodDiariesApi - object-oriented interface
 * @export
 * @class FoodDiariesApi
 * @extends {BaseAPI}
 */
export class FoodDiariesApi extends BaseAPI {
    /**
     * 
     * @param {AddFoodDiaryRequest} addFoodDiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiariesApi
     */
    public addFoodDiary(addFoodDiaryRequest: AddFoodDiaryRequest, options?: RawAxiosRequestConfig) {
        return FoodDiariesApiFp(this.configuration).addFoodDiary(addFoodDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiariesApi
     */
    public deleteFoodDiary(id: string | null, options?: RawAxiosRequestConfig) {
        return FoodDiariesApiFp(this.configuration).deleteFoodDiary(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiariesApi
     */
    public getFoodDiaryById(id: string | null, options?: RawAxiosRequestConfig) {
        return FoodDiariesApiFp(this.configuration).getFoodDiaryById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateFoodDiaryRequest} updateFoodDiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodDiariesApi
     */
    public updateFoodDiary(updateFoodDiaryRequest: UpdateFoodDiaryRequest, options?: RawAxiosRequestConfig) {
        return FoodDiariesApiFp(this.configuration).updateFoodDiary(updateFoodDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodsApi - axios parameter creator
 * @export
 */
export const FoodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFoodById: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFoodById', 'id', id)
            const localVarPath = `/api/foods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} searchParam 
         * @param {number | null} [page] 
         * @param {number | null} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFoodsByName: async (searchParam: string | null, page?: number | null, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchParam' is not null or undefined
            assertParamExists('searchFoodsByName', 'searchParam', searchParam)
            const localVarPath = `/api/foods/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchParam !== undefined) {
                localVarQueryParameter['searchParam'] = searchParam;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} cookieFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFoodApiCookies: async (cookieFile: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cookieFile' is not null or undefined
            assertParamExists('updateFoodApiCookies', 'cookieFile', cookieFile)
            const localVarPath = `/api/foods/food-api-cookies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (cookieFile !== undefined) { 
                localVarFormParams.append('cookieFile', cookieFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodsApi - functional programming interface
 * @export
 */
export const FoodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFoodById(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFoodById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodsApi.getFoodById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} searchParam 
         * @param {number | null} [page] 
         * @param {number | null} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFoodsByName(searchParam: string | null, page?: number | null, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedListOfFoodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFoodsByName(searchParam, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodsApi.searchFoodsByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} cookieFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFoodApiCookies(cookieFile: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFoodApiCookies(cookieFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodsApi.updateFoodApiCookies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodsApi - factory interface
 * @export
 */
export const FoodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodsApiFp(configuration)
    return {
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFoodById(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<FoodDto> {
            return localVarFp.getFoodById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} searchParam 
         * @param {number | null} [page] 
         * @param {number | null} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFoodsByName(searchParam: string | null, page?: number | null, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<PagedListOfFoodDto> {
            return localVarFp.searchFoodsByName(searchParam, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} cookieFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFoodApiCookies(cookieFile: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFoodApiCookies(cookieFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodsApi - object-oriented interface
 * @export
 * @class FoodsApi
 * @extends {BaseAPI}
 */
export class FoodsApi extends BaseAPI {
    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodsApi
     */
    public getFoodById(id: string | null, options?: RawAxiosRequestConfig) {
        return FoodsApiFp(this.configuration).getFoodById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} searchParam 
     * @param {number | null} [page] 
     * @param {number | null} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodsApi
     */
    public searchFoodsByName(searchParam: string | null, page?: number | null, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return FoodsApiFp(this.configuration).searchFoodsByName(searchParam, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} cookieFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodsApi
     */
    public updateFoodApiCookies(cookieFile: File, options?: RawAxiosRequestConfig) {
        return FoodsApiFp(this.configuration).updateFoodApiCookies(cookieFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoalsApi - axios parameter creator
 * @export
 */
export const GoalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddGoalRequest} addGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal: async (addGoalRequest: AddGoalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addGoalRequest' is not null or undefined
            assertParamExists('addGoal', 'addGoalRequest', addGoalRequest)
            const localVarPath = `/api/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addGoalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GoalType} goalType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveGoal: async (goalType: GoalType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalType' is not null or undefined
            assertParamExists('getActiveGoal', 'goalType', goalType)
            const localVarPath = `/api/goals/active-goal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (goalType !== undefined) {
                localVarQueryParameter['goalType'] = goalType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateGoalRequest} updateGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal: async (updateGoalRequest: UpdateGoalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateGoalRequest' is not null or undefined
            assertParamExists('updateGoal', 'updateGoalRequest', updateGoalRequest)
            const localVarPath = `/api/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGoalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddGoalRequest} addGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGoal(addGoalRequest: AddGoalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGoal(addGoalRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.addGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GoalType} goalType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveGoal(goalType: GoalType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveGoal(goalType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.getActiveGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateGoalRequest} updateGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoal(updateGoalRequest: UpdateGoalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoal(updateGoalRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.updateGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoalsApiFp(configuration)
    return {
        /**
         * 
         * @param {AddGoalRequest} addGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal(addGoalRequest: AddGoalRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdResponse> {
            return localVarFp.addGoal(addGoalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GoalType} goalType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveGoal(goalType: GoalType, options?: RawAxiosRequestConfig): AxiosPromise<GoalDto> {
            return localVarFp.getActiveGoal(goalType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateGoalRequest} updateGoalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(updateGoalRequest: UpdateGoalRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGoal(updateGoalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI {
    /**
     * 
     * @param {AddGoalRequest} addGoalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public addGoal(addGoalRequest: AddGoalRequest, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).addGoal(addGoalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GoalType} goalType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getActiveGoal(goalType: GoalType, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).getActiveGoal(goalType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateGoalRequest} updateGoalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public updateGoal(updateGoalRequest: UpdateGoalRequest, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).updateGoal(updateGoalRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NutritionDiariesApi - axios parameter creator
 * @export
 */
export const NutritionDiariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string | null} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNutritionDiariesByDate: async (date: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getNutritionDiariesByDate', 'date', date)
            const localVarPath = `/api/nutrition-diaries/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalCaloriesByPeriod: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getTotalCaloriesByPeriod', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getTotalCaloriesByPeriod', 'endDate', endDate)
            const localVarPath = `/api/nutrition-diaries/total-calories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NutritionDiariesApi - functional programming interface
 * @export
 */
export const NutritionDiariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NutritionDiariesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string | null} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNutritionDiariesByDate(date: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNutritionDiariesByDateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNutritionDiariesByDate(date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NutritionDiariesApi.getNutritionDiariesByDate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalCaloriesByPeriod(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalCaloriesByPeriod(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NutritionDiariesApi.getTotalCaloriesByPeriod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NutritionDiariesApi - factory interface
 * @export
 */
export const NutritionDiariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NutritionDiariesApiFp(configuration)
    return {
        /**
         * 
         * @param {string | null} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNutritionDiariesByDate(date: string | null, options?: RawAxiosRequestConfig): AxiosPromise<GetNutritionDiariesByDateResponse> {
            return localVarFp.getNutritionDiariesByDate(date, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalCaloriesByPeriod(startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getTotalCaloriesByPeriod(startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NutritionDiariesApi - object-oriented interface
 * @export
 * @class NutritionDiariesApi
 * @extends {BaseAPI}
 */
export class NutritionDiariesApi extends BaseAPI {
    /**
     * 
     * @param {string | null} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NutritionDiariesApi
     */
    public getNutritionDiariesByDate(date: string | null, options?: RawAxiosRequestConfig) {
        return NutritionDiariesApiFp(this.configuration).getNutritionDiariesByDate(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} startDate 
     * @param {string} endDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NutritionDiariesApi
     */
    public getTotalCaloriesByPeriod(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return NutritionDiariesApiFp(this.configuration).getTotalCaloriesByPeriod(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecipeDiariesApi - axios parameter creator
 * @export
 */
export const RecipeDiariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddRecipeDiaryRequest} addRecipeDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRecipeDiary: async (addRecipeDiaryRequest: AddRecipeDiaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addRecipeDiaryRequest' is not null or undefined
            assertParamExists('addRecipeDiary', 'addRecipeDiaryRequest', addRecipeDiaryRequest)
            const localVarPath = `/api/recipe-diaries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addRecipeDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipeDiary: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRecipeDiary', 'id', id)
            const localVarPath = `/api/recipe-diaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeDiaryById: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRecipeDiaryById', 'id', id)
            const localVarPath = `/api/recipe-diaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateRecipeDiaryRequest} updateRecipeDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeDiary: async (updateRecipeDiaryRequest: UpdateRecipeDiaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRecipeDiaryRequest' is not null or undefined
            assertParamExists('updateRecipeDiary', 'updateRecipeDiaryRequest', updateRecipeDiaryRequest)
            const localVarPath = `/api/recipe-diaries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecipeDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipeDiariesApi - functional programming interface
 * @export
 */
export const RecipeDiariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecipeDiariesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddRecipeDiaryRequest} addRecipeDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRecipeDiary(addRecipeDiaryRequest: AddRecipeDiaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRecipeDiary(addRecipeDiaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeDiariesApi.addRecipeDiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecipeDiary(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecipeDiary(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeDiariesApi.deleteRecipeDiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipeDiaryById(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeDiaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipeDiaryById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeDiariesApi.getRecipeDiaryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateRecipeDiaryRequest} updateRecipeDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeDiary(updateRecipeDiaryRequest: UpdateRecipeDiaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeDiary(updateRecipeDiaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeDiariesApi.updateRecipeDiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecipeDiariesApi - factory interface
 * @export
 */
export const RecipeDiariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecipeDiariesApiFp(configuration)
    return {
        /**
         * 
         * @param {AddRecipeDiaryRequest} addRecipeDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRecipeDiary(addRecipeDiaryRequest: AddRecipeDiaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdResponse> {
            return localVarFp.addRecipeDiary(addRecipeDiaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipeDiary(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRecipeDiary(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeDiaryById(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<RecipeDiaryDto> {
            return localVarFp.getRecipeDiaryById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateRecipeDiaryRequest} updateRecipeDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeDiary(updateRecipeDiaryRequest: UpdateRecipeDiaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRecipeDiary(updateRecipeDiaryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecipeDiariesApi - object-oriented interface
 * @export
 * @class RecipeDiariesApi
 * @extends {BaseAPI}
 */
export class RecipeDiariesApi extends BaseAPI {
    /**
     * 
     * @param {AddRecipeDiaryRequest} addRecipeDiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeDiariesApi
     */
    public addRecipeDiary(addRecipeDiaryRequest: AddRecipeDiaryRequest, options?: RawAxiosRequestConfig) {
        return RecipeDiariesApiFp(this.configuration).addRecipeDiary(addRecipeDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeDiariesApi
     */
    public deleteRecipeDiary(id: string | null, options?: RawAxiosRequestConfig) {
        return RecipeDiariesApiFp(this.configuration).deleteRecipeDiary(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeDiariesApi
     */
    public getRecipeDiaryById(id: string | null, options?: RawAxiosRequestConfig) {
        return RecipeDiariesApiFp(this.configuration).getRecipeDiaryById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateRecipeDiaryRequest} updateRecipeDiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeDiariesApi
     */
    public updateRecipeDiary(updateRecipeDiaryRequest: UpdateRecipeDiaryRequest, options?: RawAxiosRequestConfig) {
        return RecipeDiariesApiFp(this.configuration).updateRecipeDiary(updateRecipeDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecipesApi - axios parameter creator
 * @export
 */
export const RecipesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string | null} recipeId 
         * @param {AddIngredientRequest} addIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIngredient: async (recipeId: string | null, addIngredientRequest: AddIngredientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('addIngredient', 'recipeId', recipeId)
            // verify required parameter 'addIngredientRequest' is not null or undefined
            assertParamExists('addIngredient', 'addIngredientRequest', addIngredientRequest)
            const localVarPath = `/api/recipes/{recipeId}/ingredients`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addIngredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateRecipeRequest} createRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe: async (createRecipeRequest: CreateRecipeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRecipeRequest' is not null or undefined
            assertParamExists('createRecipe', 'createRecipeRequest', createRecipeRequest)
            const localVarPath = `/api/recipes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRecipe', 'id', id)
            const localVarPath = `/api/recipes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeById: async (id: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRecipeById', 'id', id)
            const localVarPath = `/api/recipes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} recipeId 
         * @param {string | null} ingredientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeIngredient: async (recipeId: string | null, ingredientId: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('removeIngredient', 'recipeId', recipeId)
            // verify required parameter 'ingredientId' is not null or undefined
            assertParamExists('removeIngredient', 'ingredientId', ingredientId)
            const localVarPath = `/api/recipes/{recipeId}/ingredients/{ingredientId}`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)))
                .replace(`{${"ingredientId"}}`, encodeURIComponent(String(ingredientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} recipeId 
         * @param {string | null} ingredientId 
         * @param {UpdateIngredientRequest} updateIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient: async (recipeId: string | null, ingredientId: string | null, updateIngredientRequest: UpdateIngredientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('updateIngredient', 'recipeId', recipeId)
            // verify required parameter 'ingredientId' is not null or undefined
            assertParamExists('updateIngredient', 'ingredientId', ingredientId)
            // verify required parameter 'updateIngredientRequest' is not null or undefined
            assertParamExists('updateIngredient', 'updateIngredientRequest', updateIngredientRequest)
            const localVarPath = `/api/recipes/{recipeId}/ingredients/{ingredientId}`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)))
                .replace(`{${"ingredientId"}}`, encodeURIComponent(String(ingredientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateIngredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | null} id 
         * @param {UpdateRecipeNameRequest} updateRecipeNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeName: async (id: string | null, updateRecipeNameRequest: UpdateRecipeNameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeName', 'id', id)
            // verify required parameter 'updateRecipeNameRequest' is not null or undefined
            assertParamExists('updateRecipeName', 'updateRecipeNameRequest', updateRecipeNameRequest)
            const localVarPath = `/api/recipes/{id}/name`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecipeNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipesApi - functional programming interface
 * @export
 */
export const RecipesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecipesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string | null} recipeId 
         * @param {AddIngredientRequest} addIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addIngredient(recipeId: string | null, addIngredientRequest: AddIngredientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addIngredient(recipeId, addIngredientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.addIngredient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateRecipeRequest} createRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipe(createRecipeRequest: CreateRecipeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipe(createRecipeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.createRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecipe(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecipe(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.deleteRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipeById(id: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.getRecipeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.getRecipes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} recipeId 
         * @param {string | null} ingredientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeIngredient(recipeId: string | null, ingredientId: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeIngredient(recipeId, ingredientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.removeIngredient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} recipeId 
         * @param {string | null} ingredientId 
         * @param {UpdateIngredientRequest} updateIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIngredient(recipeId: string | null, ingredientId: string | null, updateIngredientRequest: UpdateIngredientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIngredient(recipeId, ingredientId, updateIngredientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.updateIngredient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string | null} id 
         * @param {UpdateRecipeNameRequest} updateRecipeNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeName(id: string | null, updateRecipeNameRequest: UpdateRecipeNameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeName(id, updateRecipeNameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.updateRecipeName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecipesApi - factory interface
 * @export
 */
export const RecipesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecipesApiFp(configuration)
    return {
        /**
         * 
         * @param {string | null} recipeId 
         * @param {AddIngredientRequest} addIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIngredient(recipeId: string | null, addIngredientRequest: AddIngredientRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdResponse> {
            return localVarFp.addIngredient(recipeId, addIngredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateRecipeRequest} createRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(createRecipeRequest: CreateRecipeRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdResponse> {
            return localVarFp.createRecipe(createRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeById(id: string | null, options?: RawAxiosRequestConfig): AxiosPromise<RecipeDto> {
            return localVarFp.getRecipeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipes(options?: RawAxiosRequestConfig): AxiosPromise<Array<RecipeDto>> {
            return localVarFp.getRecipes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} recipeId 
         * @param {string | null} ingredientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeIngredient(recipeId: string | null, ingredientId: string | null, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeIngredient(recipeId, ingredientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} recipeId 
         * @param {string | null} ingredientId 
         * @param {UpdateIngredientRequest} updateIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient(recipeId: string | null, ingredientId: string | null, updateIngredientRequest: UpdateIngredientRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateIngredient(recipeId, ingredientId, updateIngredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | null} id 
         * @param {UpdateRecipeNameRequest} updateRecipeNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeName(id: string | null, updateRecipeNameRequest: UpdateRecipeNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRecipeName(id, updateRecipeNameRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecipesApi - object-oriented interface
 * @export
 * @class RecipesApi
 * @extends {BaseAPI}
 */
export class RecipesApi extends BaseAPI {
    /**
     * 
     * @param {string | null} recipeId 
     * @param {AddIngredientRequest} addIngredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public addIngredient(recipeId: string | null, addIngredientRequest: AddIngredientRequest, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).addIngredient(recipeId, addIngredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateRecipeRequest} createRecipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public createRecipe(createRecipeRequest: CreateRecipeRequest, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).createRecipe(createRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public deleteRecipe(id: string | null, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).deleteRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getRecipeById(id: string | null, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).getRecipeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getRecipes(options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).getRecipes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} recipeId 
     * @param {string | null} ingredientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public removeIngredient(recipeId: string | null, ingredientId: string | null, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).removeIngredient(recipeId, ingredientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} recipeId 
     * @param {string | null} ingredientId 
     * @param {UpdateIngredientRequest} updateIngredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public updateIngredient(recipeId: string | null, ingredientId: string | null, updateIngredientRequest: UpdateIngredientRequest, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).updateIngredient(recipeId, ingredientId, updateIngredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | null} id 
     * @param {UpdateRecipeNameRequest} updateRecipeNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public updateRecipeName(id: string | null, updateRecipeNameRequest: UpdateRecipeNameRequest, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).updateRecipeName(id, updateRecipeNameRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} updateCurrentUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (updateCurrentUserRequest: UpdateCurrentUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCurrentUserRequest' is not null or undefined
            assertParamExists('updateCurrentUser', 'updateCurrentUserRequest', updateCurrentUserRequest)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCurrentUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} updateCurrentUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(updateCurrentUserRequest: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(updateCurrentUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} updateCurrentUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(updateCurrentUserRequest: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCurrentUserRequest} updateCurrentUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateCurrentUser(updateCurrentUserRequest: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



